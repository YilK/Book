## 快速排序

### 算法步骤

1. 选取基准值（以下选取数组开头为主元）；
2. 小于等于基准值的放左边，大于等于基准值的放右边；
3. 分别对左边，右边递归，即重复 1，2 步。

### 算法复杂度

最好：O(n×log(n))

最差:O(n²)



### 如何选取基准值

1. 选择数组中的第一个元素。成本低，最简单的方法
2. 随机选择一个。
3. 取中位数。
4. 取数组第一个元素、最后一个元素、中间元素这三个元素的中位数。



### 遇到相等的元素怎么办？

左右扫描，如果遇到和基准值相等的元素怎么办？是暂停扫描还是继续扫描？

首先，两个方向采取的策略应该是一样的，也就是要么都暂停（然后交换），要么都继续扫描。否则将导致两个子数组不平衡。

其次，为了更好分析这个问题，我们不妨考虑所有元素都相同的情形。如果我们遇到和pivot相等的时候不停止，那么从左到右扫描时，两指针将相遇，此次过程结束。结果呢？什么都没做，却得到了两个大小极其不均衡的数组。算法时间复杂度为O(n2n2)。如果我们选择遇到相等元素时停止扫描，然后交换，那么虽然看上去交换的次数变多了，但是我们将得到大小相等（或者差1）的两个子数组。算法的时间复杂度为O(nlgnnlgn)。

因此，遇到和基准值相等的元素时候我们都暂停扫描，交换元素后继续，直到指针相遇或者交叉。